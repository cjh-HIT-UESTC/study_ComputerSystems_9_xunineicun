9.8内存映射
内存映射就是：把虚拟内存区域 与一个磁盘上的对象关联起来  这样就初始化了这个虚拟内存区域的内容 就像int a =1; int a就像这个虚拟内存区域 1就是磁盘上的对象
一旦虚拟页面被初始化了   他就在一个交换空间中 换来换去  所以一旦虚拟页面太多了 就无法很好的交换    所以交换空间限制着当前进程能分配的虚拟页面的总数
9.8.1
之所以要发明内存映射 是因为这样能 很简单高效的把程序和数据加载到内存中  并且   能够很方便的来共享需要共享的对象（数据、代码等）  也能很方便的管理私有对象
比如：一个共享对象   对于每个进程而言可以使用不同的虚拟内存地址来表示它 然后映射到物理内存中同一个地方 实现了共享对象
      一个私有对象  在初始时依旧只有一份物理地址  如果多个进程都有它 则多个进程中的虚拟地址都指向它
                一旦某个进程要写这个私有对象时  就通过写时复制：  把只需要写的部分 复制到另一块物理地址处 在这个新的地方写需要写的私有东西   没有复制的部分依旧由所有进程共享
                这样就大大节约了物理内存
9.8.2 fork函数
一个进程，包括代码、数据和分配给进程的资源。
fork（）函数通过系统调用创建一个与原来进程几乎完全相同的进程，也就是两个进程可以做完全相同的事，但如果初始参数或者传入的变量不同，两个进程也可以做不同的事。
一个进程调用fork（）函数后，系统先给新的进程分配资源，例如存储数据和代码的空间。然后把原来的进程的所有值都复制到新的新进程中，只有少数值与原来的进程的值不同。
相当于克隆了一个自己。
那么就能很清楚fork函数的运行机制了：在一个进程中调用fork函数后，创建了一个拥有的东西与之前的进程一模一样的进程，但是唯一最重要的东西就是：新进程里的这些东西全部被标记为私有的写时复制
      这样一来，这个新进程就和原进程拥有相同的虚拟内存，但又由于是私有的，于是一旦对某个进程进行写操作时，就会触发写时复制的操作，从而在物理内存中创建了新的属于新进程的页面、
9.8.3execve函数
  execve() – 叫做执行程序函数，可以调用其他程序的执行，执行shell命令，，调用脚本等等功能。
  定义： int execve(const char *filename, char *const argv[], char *const envp[]); 
  int main(int arg, char **args)
  {
      char *argv[]={"ls","-al","/home/chicho/result/", NULL};
      char *envp[]={0,NULL}; //传递给执行文件新的环境变量数组
      execve("/bin/ls",argv,envp);                      调用execve函数来执行文件
  }
在一个进程中调用后，这个调用的程序就有效的替代了当前程序，它调用后执行的步骤：
1、删除原进程的用户区域
2、映射私有区域：即是它自己的数据、代码等，全部映射为私有，并写时复制，一旦对它们进行写操作，就触发写时复制，创建新的物理内存
3、映射共享区域：如果这个进程包含一些共享对象，比如一些头文件等，那么就映射到共享区域
4、设置程序计数器：因为之前的程序计数器指向的是调用execve函数的位置，那么现在把它设置成指向代码区域的入口点，用来控制程序的运行
9.8.4mmap函数
mmap将一个文件或者其它对象映射进内存。文件被映射到多个页上，如果文件的大小不是所有页的大小之和，最后一个页不被使用的空间将会清零。
mmao函数 让内核创建一个新的虚拟内存区域，然后把对象映射到这个虚拟内存区域
munmap函数 用来删除虚拟内存的区域

以上都是说明了这些函数的运行机制  实际上都是通过内存映射和私有写时复制 来创建新的内存空间的

9.9动态内存分配
尽管mmap与munmap可以用来创建和删除虚拟内存的区域，但是它们比较低级（不好使用）
所以出现了动态内存分配器（我猜，是因为存在隐式分配的原因，系统可以自动的释放内存）  实际是由于直到程序实际运行时，才直到某些数据结构的大小

动态内存分配器维护这一个进程的虚拟内存区域，称为 ：堆  （它的堆顶 有一个变量叫做：brk）
  堆 被分为一组不同大小的块的集合来维护  每个块要么已分配 要么是空闲的
分配器有两种风格：
1、显示分配器   也就是malloc  和 free（c）     new和delete（C++）
2、隐式分配器   当一个已分配块不再使用的时候，就自动释放这个块。 这个隐式分配器叫：垃圾收集器  释放过程叫：垃圾收集

9.9.1 malloc和free函数
 malloc函数 从堆中分配块   它返回一个指针，指向分配到那个内存块  这个块会自动的为用它的数据对象类型作对齐（理解为不管对象是什么类型，它自动适应）
 malloc函数没有初始化它返回的内存  calloc是初始化了它返回的内存  realloc函数是可以用来改变已分配块的大小
 sbrk函数：通过将内核的brk指针增加指定的值来扩展和收缩堆
 free函数使用时，需要注意的是，free的对象必须是malloc,calloc,realloc的已分配块的起始位置
 9.9.2
为什么需要使用动态内存分配？： 是由于直到程序实际运行时，才直到某些数据结构的大小、
静态：提前定义好       动态：运行起来后，再定义       就像matlab里的：a[100]：静态，提前分配好100个数据位    A[]动态分配，等程序运行起来后才知道需要多少数据位
C中：array[100]         与scanf("%d",n)   malloc(n*sizeof(int)) 动态分配   然后再释放free(array)
9.9.3
最大化吞吐率：定义为在每个单位时间里完成的请求数    为了提高它就需要让分配命令和释放命令 的时间变短  意味着操作的内存变小 所以与最大化空间利用率矛盾
最大化空间利用率：因为虚拟内存的全部数量是受到磁盘上的交换空间的数量控制的 所以内存有限  所以要提高利用率  所以才会需要每分配完之后释放（一定要free!!!!!!!!!!!）
9.9.4碎片
造成堆利用率很低的一个原因是一种叫 碎片的现象    即是 虽然有没有使用的内存但不能用来满足分配请求时
分为内部碎片和外部碎片
内部碎片：像书的589页的图，很好理解，就是两段分配块之间的 未分配块小了，不能满足新的需求，就变成了内部碎片     一个是内部块太小
外部碎片：也很好理解，就是需要的块大小太大了，没有单独的空闲块能满足                                      一个是外部需求太大
因为外部碎片难以预料，所以计算机主要策略是处理内部碎片，使内部碎片尽量的少与小

9.9.6 隐式空闲链表
首先 块本身被组成成有一定结构的数据体 核心是它有着标记它是否被分配的标记位和 指向它有效载荷的指针
  于是 利用这种结构 就能把 堆 组织成  一个连续的的已分配块和空闲块的序列
  实际上： 就是利用指针，先把所有的已分配块链接起来，再把空闲块链接起来
这样就构成了 隐式空闲链表（因为空闲块是通过头部中的字段隐含地链接的）
它的特点是 简单，缺点是 任何操作的开销很大（因为它是通过指针相连的，所以比如放置分配的块，需要对空闲链表进行搜索，找到合适的那个位置的指针）
9.9.7放置已分配块的策略
首次适配：从头开始搜索，选择第一个合适的空闲块（每次都是从头搜索）       适中趋向于把大的空闲块留在链表的后面
下一次适配：不是从头搜索，而是从上一次结束的位置开始搜索               内存利用率最低，速度最快
最佳适配：检查每个空闲块，选择其中合适的最小的空闲块                  内存李永禄最高，速度最低
9.9.8分割空闲块
当找到了合适的空闲块，就需要开始进行分配，但是如果用不完，就可以把内存块分割成两部分，一部分是刚好的需要的大小，另一部分就是新的内存块
9.9.9获取额外的堆内存
当找不到合适大小的空闲块时（太小了），就需要把物理上相邻的空闲块合并成更大的内存块，当已经合并到不能再合并时，并且还不够，就像内核请求额外的堆内存
9.9.10合并空闲块
讲的就是 当分配的块被释放后 就可能需要合并   这时合并的策略就有两种，一种是立即合并  另一种是推迟合并
立即合并可能会导致抖动：也就是在某种情况下，反复的合并，再马上被分割，会导致分配器速度降低，所以有时为了提高速度会设计推迟合并
9.9.11带边界标记的合并
边界标记：实际上就是在每个块的结尾处添加一个脚部（标记位）
相当于多了一个标记位 就能更好的合并了


























        

